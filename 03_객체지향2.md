# Ch07
## 상속
- 기존의 클래스로 새로운 클래스를 작성하는 것(코드의 재사용)
- 두 클래스를 부모와 자식으로 관계를 맺어주는 것
```java
class 자식클래스 extends 부모클래스{
    ...
}
```
```java
class Parent { }
class Child extends Parent {
    ...
}
```
- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
- 자손의 멤버 개수는 조상보다 적을 수 없다. (같거나 많다.)
- 자손의 변경은 조상에 영향을 미치지 않는다.
```java
class Point {
    int x;
    int y;
}

class Point3D extends Point {
    int z;
}
```
- 위와 아래의 코드는 객체 생성하면 똑같은 결과를 갖는다.
```java
class Point3D {
    int x;
    int y;
    int z;
}
```
## 포함 관계
- 클래스의 멤버로 참조변수를 선언하는 것
- 작은 단위의 클래스를 만들고, 이 들을 조합해서 클래스를 만든다.
```java
class Circle {
    int x;
    int y;
    int r; 
}
```
- ```java
  Circle c = new Circle();
  // x에 접근
  c.x = ...
  ```
```java
class Point {
    int x;
    int y;
}

class Circle {
    Point p = new Point();
    int r;
}
```
- ```java
  Circle c = new Circle();
  // x에 접근
  c.p.x = ...
  ```
## 클래스의 관계 결정하기
- 상속관계 : `A는 B다.(is-a)`
    - 제약이 많기 때문에 꼭 필요할때만 상속
- 포함관계 : `A는 B를 가지고있다.(has-a)`
    - 90% 이상이 포함관계

## 단일상속
- 단일상속 : 하나의 부모만 상속 가능한 것
- Java는 단일 상속만을 허용한다. (C++은 다중상속 허용)
```java
class TvDVD extends Tv, DVD {   // 에러. 조상은 하나만 허용된다.
    ...
}
```
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 하면 다중상속의 효과를 낼 수 있다.

## Object 클래스 - 모든 클래스의 조상
- 부모가 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
    - 컴파일러가 자동으로 `extends Object`를 추가해줌
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다.
    - ex) toString()...
- println()은 참조변수가 들어오면 toString()을 호출하기 때문에 `println(참조변수.toString)`이나 `println(참조변수)`나 같은 값을 호출한다.
    - toString은 기본으로 `클래스이름@주소`를 반환한다.
## 오버라이딩(overriding)
- 상속받은 조상의 **메서드**를 자신에 맞게 변경하는 것
```java
class Point {
    int x;
    int y;

    String getLocation() {
        return "x :" + x + ", y :" + y;
    }

}

class Point3D extends Point {
    int z;

    String getLocation() {
        return "x :" + x + ", y :" + y+ ", z :" + z;
    }
}
```
- 선언부 변경불가, 구현부만 변경 가능

## 오버라이딩의 조건
1. 선언부가 조상 클래스의 메서드와 일치해야 한다.
    - 선언부 : 반환타입, 메서드이름, 매개변수들
2. 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

## 오버로딩 vs 오버라이딩
- 이름만 비슷하지 전혀 관계 없음
- 오버로딩(overloading): 기존에 없는 새로운 메서드를 정의하는 것(new)
    - 상속과 관계 x
- 오버라이딩(overriding): 상속받은 메서드의 내용을 변경하는 것(change, modify)
```java
class Parent {
    void parentMethod() {}
}

class Child extends Parent {
    void parentMethod() {}          // 오버라이딩
    void parentMethod(int i) {}     // 오버로딩

    void childMethod() {}           
    void childMethod(int i) {}      // 오버로딩
    void childMethod() {}           // 에러: 메서드 중복정의
}
```
## 참조변수 super
- 객체 자신을 가리키는 참조변수. 인스턴스 메서드(생성자 포함)내에만 존재
- 조상의 멤버(super)와 자신의 멤버(this)를 구별할 때 사용

## super() - 조상의 생성자
- 조상의 생성자를 호출할 때 사용
- 조상의 멤버는 조상의 생성자를 호출해서 초기화
- **모든 생성자는 생성자의 첫 줄에 반드시 생성자(super()나 this())를 호출해야 한다.**
    - 그렇지 않으면 컴파일러가 생성자의 첫 줄에`super();`를 삽입
### Ex1
```java
class Point {
    int x, y;

    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```
```java
class Point3D extends Point {
    int z;

    Point3D(int x, int y, int z) {
        this.x = x;     // 조상의 멤버를 초기화
        this.y = y;     // 조상의 멤버를 초기화
        this.z = z;
    }
}
```
- 위의 경우 자손이 조상의 멤버를 초기화하고 있는 형태이므로 이런 방식은 바람직하지 않다.
```java
Point3D(int x, int y, int z) {
    super(x, y);    // 조상클래스의 생성자 Point(int x, int y)를 호출
    this.z = z;     // 자신의 멤버를 초기화
}
```
- 위의 방법으로 해야한다.
### Ex2.
```java
class Point {
    int x;
    int y;

    Point(int x, int y) {
        // super();     // Object(); 자동 호출
        this.x = x;
        this.y = y;
    }

    String getLocation() {
        return "x :"+x+", y :"+y;
    }
}

class Point3D extends Point {
    int z;

    Point3D(int x, int y, int z) {
        // super();     // 첫 줄에 생성자 호출 안했으니까 Point()가 자동 호출됨
        
        // 근데 Point에는 기본생성자Point()가 없으므로 에러가 발생
        // 따라서 기본생성자는 클래스 만들 때 컴파일러가 만들어주기를 기대하지말고 반드시 만들라는 것임
        this.x = x;
        this.y = y;
        this.z = z;
    }

    String getLocation() {
        return "x :"+x+", y :"+y+", z :"+z;
    }
}
```
- 이 에러를 해결하기 위한 두 가지 방법이 있다.
1. Point 클래스에 Point() 기본 생성자 작성
    - **하지만 이 방법은 클래스를 만들 때 기본적으로 우선 수행되어야 하는 것이다.**
    - 클래스 만들 때 항상 기본 생성자를 작성하는 버릇을 들이도록 하자.
2. 조상의 생성자 `Point(int x, int y)`를 super()로 호출
```java
Point3D(int x, int y, int z) {
    super(x, y);
    this.z = z;
}
```

## 패키지
- 서로 관련된 클래스의 묶음
- 클래스는 클래스 파일(*.class), 패키지는 폴더. 하위 패키지는 하위 폴더
- 클래스의 실제이름(full name)은 패키지를 포함(java.lang.String)

### 패키지의 선언
- 패키지는 소스파일의 첫 번째 문장으로 단 한번 선언
- 같은 소스 파일의 클래스들은 모두 같은 패키지에 속하게 된다.
- 패키지 선언이 없으면 이름없는(unnamed) 패키지에 속하게 된다.

### 클래스 패스(classpath)
- 클래스 파일(*.class)의 위치를 알려주는 경로(path)
- 환경변수 classpath로 관리하며, 경로간의 구분자는 ';'를 사용
    - classpath(환경변수)에 패키지의 루트를 등록해줘야 함
