# Ch09
## Object 클래스
- 모든 클래스의 최고 조상. 오직 11개의 메서드만을 가지고 있다.
- `notify()`, `wait()` 등은 쓰레드와 관련된 메서드이다.

|Object클래스의 메서드|설명|
|---|---|
|**protected** Object clone()|객체 자신의 복사본을 반환한다.|
|public boolean equals(Object obj)|객체 자신과 객체 obj가 같은 객체인지 알려준다.(같으면 true)|
|**protected** void finalize()|객체가 소멸될 때 가비지 컬렉터에 의해 자동적으로 호출된다. 이 때 수행되어야 하는 코드가 있으면 오버라이딩한다.(거의 사용안함)|
|public Class getClass()|객체 자신의 클래스 정보를 담고 있는 Class 인스턴스를 반환한다.(앞글자 대문자임)|
|public int hashCode()|객체 자신의 해시코드를 반환한다.|
|public String toString()|객체 자신의 정보를 문자열로 반환한다.|
|public void notify()|객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.|
|public void notifyAll()|객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.|
|public void wait()<br>public void wait(long timeout)<br>public void wait(long timeout, int nanos)|다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다.(timeout은 천 분의 1초, nanos는10^9분의 1초)|

- 이 메서드들은 우리가 작성하는 클래스에 맞게 기본적으로 오버라이딩 하는 경우가 많다.
- 메서드에 접근제어자가 protected로 되어있는 것들은 오버라이딩 해서 public으로 변경해야한다.
- `public Class getClass()`
    - Hello.java라는 파일을 컴파일한 Hello.class 파일이 메모리에 올라갈 때 Hello의 Class객체가 생성된다. 
    - Class객체에는 클래스에 대한 모든 정보가 들어있다(iv는 몇개인지 생성자는 몇개인지와 같은...)
    - 따라서 해당 메서드를 사용하면 Class객체를 반환하기 때문에
        - 객체를 생성할 수 있고
        - 객체의 정보를 알 수 있다.
## boolean equals(Object obj)
- 객체 자신(this)과 주어진 객체의 주소를 비교한다. 같으면 true, 다르면 false
```java
public boolean equals(Object obj) {
    return (this==obj)
}
```
- 인스턴스 변수(iv)의 값을 비교하도록 equals()를 오버라이딩해야 한다.
```java
class Person {
	long id;

	public boolean equals(Object obj) {
		if(!(obj instanceof Person))
			return false;
		
		return id == ((Person)obj).id;
	}

	Person(long id) {
		this.id = id;
	}
}

class Ex9_2 {
	public static void main(String[] args) {
		Person p1 = new Person(8011081111222L);
		Person p2 = new Person(8011081111222L);

		if(p1.equals(p2))
			System.out.println("p1과 p2는 같은 사람입니다.");   
		else
			System.out.println("p1과 p2는 다른 사람입니다.");
	}
}
```
## int hashCode()
- 객체의 해시코드(hash code)를 반환하는 메서드
- Object클래스의 hashCode()는 객체의 주소를 int로 변환해서 반환
```java
public class Object {
    ...
    public native int hashCode();
}
```
- native메서드 : OS의 메서드(C언어로 작성됨). 이미 작성되어있는 메서드이기 때문에 내용이 없음.
- equals()를 오버라이딩하면, hashCode()도 오버라이딩해야 한다.
    - **equals()의 결과가 true인 두 객체의 해시코드는 같아야 하기 때문**
	- 이클립스의 source 메뉴에서 쉽게 할수있음.
- `System.identityHashCode(Object obj)`는 Object클래스의 hashCode()와 동일.
    - hashCode()를 보통 오버라이딩해서 사용하기 때문에 오버라이딩 하기 전 해시코드 값이 필요할 경우 사용
### 참고
32bit JVM에서는 주소가 4byte int값이고,  
64bit JVM에서는 주소가 8byte long값이다.  
따라서 8byte에서 4byte로 바꾸면 겹치는 주소값이 생길수도 있다.
## toString(), toString()의 오버라이딩
- toString(): 객체를 문자열(String)으로 변환하기 위한 메서드
```java
public String toString() {	// Object클래스의 toString()
    return getClass().getName()+"@"+Integer.toHexString(hashCode());
}
```
### 정리
```java
import java.util.Objects;

class Card {
	String kind;
	int number;

	Card() {
		this("SPADE", 1);
	}

	Card(String kind, int number) {
		this.kind = kind;
		this.number = number;
	}
	
	// equals()를 오버라이딩하면 hashCode()도 오버라이딩 해야한다.
	public int hashCode() {
		return Objects.hash(kind, number);
	}
	
	public boolean equals(Object obj) {
		if (!(obj instanceof Card))
			return false;
		Card c = (Card)obj;
		return this.kind.equals(c.kind) && this.number == c.number;
	}
	
	public String toString() {
		return "kind: "+kind+", number: "+number;
	}
}

class Ex9_4 {
	public static void main(String[] args) {
		Card c1 = new Card();
		Card c2 = new Card();
		System.out.println(c1.equals(c2));
		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
		System.out.println(c2.toString());
	}
}
```
output
```
true
-1842861219
-1842861219
kind: SPADE, number: 1
```

## String클래스
- String클래스 = 데이터(char[]) + 메서드(문자열 관련)
- 내용을 변경할 수 없는 불변(immutable) 클래스
	- 따라서 덧셈 연산자(+)를 이용한 문자열 결합은 성능이 떨어짐
	- 문자열의 결합이나 변경이 잦다면 내용을 변경가능한 StringBuffer를 사용

## 문자열의 비교
- `String str = "abc";`와 `String str = new String("abc");`의 비교
```java
String str1 = "abc";	// 문자열 리터럴 "abc"의 주소가 str1에 저장됨
String str2 = "abc";	// 문자열 리터럴 "abc"의 주소가 str2에 저장됨
String str3 = new String("abc");	// 새로운 String인스턴스를 생성
String str4 = new String("abc");	// 새로운 String인스턴스를 생성

str1 == str2	// true
str3 == str4	// false
str1.equals(str2)	// true
str3.equals(str4)	// true
```
![문자열비교](./img/문자열비교.jpg)

## 빈 문자열("", empty string)
- 내용이 없는 문자열. 크기가 0인 char형 배열을 저장하는 문자열  
`String str = "";`	// str을 빈 문자열로 초기화
- 크기가 0인 배열을 생성하는 것은 어느 타입이나 가능
```java
char[] chArr = new char[0];	// 길이가 0인 char배열
int[] iArr = {}; 			// 길이가 0인 int배열
```
- 문자(char)와 문자열(String)의 초기화
```java
// 적절하지 않은 방식
String s = null;
char c = '\u0000';

// 적절한 방식
String s = "";	// 빈 문자열로 초기화
char c = ' ';	// 공백으로 초기화
```
## String클래스의 생성자와 메서드
- `String(String s)`: 주어진 문자열(s)을 갖는 String 인스턴스를 생성한다.
```java
String s = new String("Hello");	// s = "Hello"
```
- `String(char[] value)`: 주어진 문자열(value)을 갖는 String 인스턴스를 생성한다.
```java
char[] c = {'H','e','l','l','o'};
String s = new String(c);	// s = "Hello"
```
- `String(StringBuffer buf)`: StringBuffer인스턴스가 갖고 있는 문자열과 같은 내용의 String인스턴스를 생성한다.
```java
StringBuffer sb = new StringBuffer("Hello");
String s = new String(sb);	// s = "Hello"
```
- `char charAt(int index)`: 지정된 위치(index)에 있는 문자를 알려준다.(index는 0부터 시작)
```java
String s = "Hello";
String n = "0123456";
char c = s.charAt(1);	// c = 'e'
char c2 = n.charAt(1);	// c2 = '1'
```
- `int compareTo(String str)`: 문자열(str)과 사전순서로 비교한다. 같으면 0을, 사전순으로 이전이면 음수를, 이후면 양수를 반환한다.
```java
int i = "aaa".compareTo("aaa");		// i = 0
int i2 = "aaa".compareTo("bbb");	// i2 = -1
int i3 = "bbb".compareTo("aaa");	// i3 = 1