## 내부 클래스(ineer class)
- 클래스 안의 클래스
```java
class A {       // 외부 클래스
    ...
    class B {   // 내부 클래스
        ...     
    }
}
```
- 내부 클래스의 장점
    - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다. 
        - 객체 생성 없이도 내부 클래스가 외부클래스의 멤버 접근 가능
    - 코드의 복잡성을 줄일 수 있다. (캡슐화)

## 내부 클래스의 종류와 특징
- 내부 클래스의 종류와 유효범위(scope)는 변수와 동일
```java
class Outer {
    int iv = 0;
    static cv = 0;
    void myMethod() {
        int lv = 0;
    }
}

class Outer {
    class InstanceInner {}
    static class StaticInner {}

    void myMethod() {
        class LocalInner {}
    }
}
```
|내부 클래스|특징|
|---|---|
|인스턴스 내부 클래스|외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버처럼 다루어진다. <br>주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.|
|스태틱 내부 클래스|외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 static멤버처럼 다루어진다. <br>주로 외부 클래스의 static멤버, 특히 static메서드에서 사용될 목적으로 선언된다.|
|지역 내부 클래스|외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.|
|익명 클래스|클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)|

## 내부 클래스의 제어자와 접근성
- 내부 클래스의 제어자는 변수에 사용가능한 제어자 4개 모두 사용 가능
- ex 1.
```java
class Ex7_12 { 
	class InstanceInner { // 인스턴스 내부 클래스
		int iv = 100; 
		static int cv = 100;            // 에러! static변수를 선언할 수 없다. 
		final static int CONST = 100;   // final static은 상수이므로 static 붙이는거 허용
	} 

   static class StaticInner { // static 내부 클래스에서는 외부 클래스의 인스턴스 멤버에 접근 불가능
		int iv = 200; 
		static int cv = 200;    // static클래스만 static멤버를 정의할 수 있다. 
	} 

	void myMethod() {   // 지역 내부 클래스
		class LocalInner { 
			int iv = 300; 
			static int cv = 300;             // 에러! static변수를 선언할 수 없다. 
			final static int CONST = 300;    // final static은 상수이므로 static 붙이는거 허용 
		} 
	}
} 
```
- ex 2.
```java
class Ex7_13 {
	class InstanceInner {}
	static class StaticInner {}

	// 인스턴스멤버 간에는 서로 직접 접근이 가능하다.
	InstanceInner iv = new InstanceInner();
	// static 멤버 간에는 서로 직접 접근이 가능하다.
	static StaticInner cv = new StaticInner();

	static void staticMethod() {
      // static멤버는 인스턴스멤버에 직접 접근할 수 없다.
//		InstanceInner obj1 = new InstanceInner();	
		StaticInner obj2 = new StaticInner();

      // 굳이 접근하려면 아래와 같이 객체를 생성해야 한다.
      // 인스턴스클래스는 외부 클래스를 먼저 생성해야만 생성할 수 있다.
		Ex7_13 outer = new Ex7_13();
		InstanceInner obj1 = outer.new InstanceInner();
	}

	void instanceMethod() {
      // 인스턴스메서드에서는 인스턴스멤버와 static멤버 모두 접근 가능하다.
		InstanceInner obj1 = new InstanceInner();
		StaticInner obj2 = new StaticInner();
		// 메서드 내에 지역적으로 선언된 내부 클래스는 외부에서 접근할 수 없다.
//		LocalInner lv = new LocalInner();
	}

	void myMethod() {
		class LocalInner {}
		LocalInner lv = new LocalInner();
	}
}
```
- ex 3.
```java
class Outer {
	private int outerIv = 0;
	static  int outerCv = 0;

	class InstanceInner {
		int iiv  = outerIv;  // 외부 클래스의 private멤버도 접근가능하다.
		int iiv2 = outerCv;
	}

	static class StaticInner {
// 스태틱 클래스는 외부 클래스의 인스턴스멤버에 접근할 수 없다.
//		int siv = outerIv;
		static int scv = outerCv;
	}

	void myMethod() {
		int lv = 0;
		final int LV = 0;  // JDK1.8부터 final 생략 가능

		class LocalInner {
			int liv  = outerIv;
			int liv2 = outerCv;
//	외부 클래스의 지역변수는 final이 붙은 변수(상수)만 접근가능하다.
//			int liv3 = lv;	// 에러!!!(JDK1.8부터 에러 아님)
			int liv4 = LV;	// OK
		}
	}
}

```
- ex3의 포인트 2개
    - 내부클래스에서 외부 클래스의 private 멤버도접근 가능하다. 
    - 지역변수는 메서드 종료와 함께 소멸되고  
    메서드 내의 내부 클래스의 객체가 지역변수보다 더 오래 존재할 수도 있으므로  
    외부 클래스의 지역변수를 사용하려면 final이 붙은 변수(상수)만 접근 가능하다.
        - JDK 1.8부터는 final 안붙은 변수인데 값이 바뀐적 없으면 상수로 취급한다.
        - 상수는 constant pool에서 따로 존재하기 때문에 메서드 종료와 상관없이 계속 사용 가능하다.

- ex 4.
	- 문법적인 내용은 그냥 문법이니까 왜그런지 이해하려 하지말고 걍 보기
```java
class Outer2 {
	class InstanceInner {
		int iv = 100;
	}

	static class StaticInner {
		int iv = 200;
		static int cv = 300;
	}

	void myMethod() {
		class LocalInner {
			int iv = 400;
		}
	}
}

class Ex7_15 {
	public static void main(String[] args) {
		// 인스턴스클래스의 인스턴스를 생성하려면
		// 외부 클래스의 인스턴스를 먼저 생성해야 한다.
		Outer2 oc = new Outer2();
		Outer2.InstanceInner ii = oc.new InstanceInner();

		System.out.println("ii.iv : "+ ii.iv);
		System.out.println("Outer2.StaticInner.cv : "+Outer2.StaticInner.cv);
                                     
	   // 스태틱 내부 클래스의 인스턴스는 외부 클래스를 먼저 생성하지 않아도 된다.
		Outer2.StaticInner si = new Outer2.StaticInner();
		System.out.println("si.iv : "+ si.iv);
	}
}
```
이 예제를 컴파일하면 5개의 클래스가 만들어진다.
```java
Ex7_15.class
Outer2.class
Outer2$InstanceInner.class
Outer2$StaticInner.class
Outer2$1LocalInner.class	// 지역 클래스는 숫자 붙음
```
- ex 5.
	- this 쓰는 방법
```java
class Outer3 {
	int value = 10;	// Outer3.this.value

	class Inner {
		int value = 20;   // this.value

		void method1() {
			int value = 30;
			System.out.println("            value :" + value);	// 가까운거. 30
			System.out.println("       this.value :" + this.value);	// 20
			System.out.println("Outer3.this.value :" + Outer3.this.value);	// 10
		}
	} // Inner클래스의 끝
} // Outer3클래스의 끝

class Ex7_16 {
	public static void main(String args[]) {
		Outer3 outer = new Outer3();
		Outer3.Inner inner = outer.new Inner();
		inner.method1();
	}
}
```

## 익명 클래스(anonymous class)
- 이름이 없는 일회용 클래스. 정의와 생성을 동시에
```java
new 조상클래스이름() {
	// 멤버 선언
}
	
	또는

new 구현인터페이스이름() {
	// 멤버 선언
}
```

<br>

- 예제 1
```java
class Ex7_17 {
	Object iv = new Object(){ void method(){} };         // 익명 클래스
	static Object cv = new Object(){ void method(){} };  // 익명 클래스

	void myMethod() {
		Object lv = new Object(){ void method(){} };      // 익명 클래스
	}
}
```
컴파일 시 생기는 클래스
```java
Ex7_17.class
Ex7_17$1.class
Ex7_17$2.class
Ex7_17$3.class
```
- 예제 2
```java
import java.awt.*;
import java.awt.event.*;

class Ex7_18 {
	public static void main(String[] args) {
		Button b = new Button("Start");
		b.addActionListener(new EventHandler());
	}
}

class EventHandler implements ActionListener {
	public void actionPerformed(ActionEvent e) {
		System.out.println("ActionEvent occurred!!!");
	}
}
```
어차피 한번만 쓰고 말 클래스를 아래와 같이 익명 클래스로 만든다.
```java
import java.awt.*;
import java.awt.event.*;

class Ex7_19 {
	public static void main(String[] args) {
		Button b = new Button("Start");
		b.addActionListener(new ActionListener() {
				public void actionPerformed(ActionEvent e) {
					System.out.println("ActionEvent occurred!!!");
				}
			} // 익명 클래스의 끝
		);
	} // main의 끝
} 
```
