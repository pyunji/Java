## 자바의 특징
- 객체지향 언어(c++, python, js...)
- 자동 메모리 관리
    - 가비지 컬렉터(GC)
- 멀티 쓰레드 지원
    - 채팅하면서 파일을 주고받을 수 있는 것은 해당 프로그램이 멀티쓰레드를 지원하는 언어로 만들어졌기 때문
- 운영체제에 독립적
## JVM
- 자바 프로그램이 실행되는 가상 컴퓨터
- 일반적으로 app은 os위에서 실행되는데, java는 os위의 JVM위에서 실행되기 때문에 운영체제 독립적이다
    - jvm이 운영체제별로 이미 만들어져있음

## JDK 자바 개발도구
## 자바 API 문서 설치와 사용법
- `C:\jdk1.8\docs\api`의 index.html
## 첫 번째 자바프로그램 작성
- javac.exe: 자바 컴파일러. 사람이 작성한 문장을 기계어로 번역
    - 소스 파일(.java)을 클래스 파일(.class)로 변환
    - `javac Hello.java` : 컴파일 명령
- java.exe: 자바 인터프리터. 자바프로그램(클래스파일)을 실행
- 클래스: 자바 프로그램의 단위
```java
class 클래스이름 {
    // 모든 문장은 클래스의 {}안에 있어야 한다.
}
```
- main 메서드: 자바 프로그램의 시작점. 이 메서드 없이 실행불가
```java
class 클래스이름 {
    public static void main(String[] args) {
        // 첫 문장부터 순서대로 실행된다.
    }
}
```
## 이클립스에서 자바 프로그램을 작성하는 순서
1. 프로젝트 생성
2. 클래스 생성
3. 소스파일 작성 후 저장 (자동컴파일됨)
4. 실행
- build: 소스파일(.java)로부터 프로그램을 만들어 내는 전 과정

## 이클립스 단축키
- `ctrl + shift + L` : 단축키 전체 목록 보기
- `ctrl + D` 한줄 삭제
- `ctrl + alt + down` : 행단위 복사
- `alt + shift + A` : 멀티 컬럼 편집 (토글)
    - `shift` 눌러 멀티 커서
- `alt + up, down`: 행단위 이동
- `ctrl + i` : 자동 들여쓰기 맞춰줌
- `ctrl + /` : 주석 (토글)
- `ctrl + space`: 자동완성

## 변수
- 하나의 값을 저장할 수 있는 메모리 공간(RAM)
### 변수의 선언
- 변수의 선언 이유: data를 저장할 공간을 마련하기 위해
- 변수의 선언 방법: `변수타입 변수이름;`
### 변수에 값 저장하기
- `변수타입 변수이름 = 값;`
- 변수의 초기화: 변수에 처음으로 값을 저장하는 것
    - 변수에는 클래스변수, 인스턴스변수, 지역변수가 있다.
    - 지역변수는 0으로 자동 초기화되지 않기 때문에 꼭 초기화해야 한다.

## 변수의 타입
- 변수의 타입은 저장할 값의 타입에 의해 결정된다.
- 저장할 값의 타입과 일치하는 타입으로 변수를 선언.
## 값의 타입
- 8개의 기본형 데이터타입 존재
### 문자
- char
### 숫자
#### 정수
- byte
- short
- int
- long
#### 실수
- float
- double
### 논리
- boolean

## 상수와 리터럴
- 상수(constant): 한 번만 값을 저장 가능한 변수
    - 변수와 달리 변경 불가능
    ```java
    final int MAX = 100;
              MAX = 200; // 에러
    ```
- 리터럴(literal) : 기존의 상수. 그 자체로 값을 의미하는 것

## 리터럴의 접두사와 접미사
- 대소문자 구별 안하지만 'L'은 웬만하면 대문자로 씀
```java
boolean power = true;
char ch = 'A';
String str = "ABC";

byte b = 127;
byte b = 128; // 에러

int i = 100; 
int oct = 0100; // 8진수 접두사 '0'
int hex = 0x100; // 16진수 접두사 '0x'
int b = 0b0101; // 2진수 접두사 '0b'

long l = 10_000_000_000L; // 100억(20억이 넘는 값은 long타입에 담아야함)
long l = 10_000_000_000; // 에러
// 20억 넘는 값은 L을 꼭 붙이고 안넘는 값은 안붙여도 됨

float f = 3.14f; // 생략불가
double d = 3.14d; // 생략가능
// 실수형은 접미사가 붙지 않으면 자동으로 double타입으로 인식됨
```
```java
10. // 10.0
.10 // 0.1
10f // 10.0f
1e3 // 1000.0d
```
## 변수와 리터럴의 타입 불일치
- 범위가 `변수 > 리터럴`인 경우 ㄱㅊ
    - 크기가 더 큰 수납공간에 작은 값을 담는거니까 ㄱㅊ
```java
int i = 'A'; // int > char
long l = 123; // long > int
double d = 3.14f // double > float
```
- 범위가 `변수 < 리터럴`인 경우 에러
```java
int i 30_0000_0000; //int의 범위(+-20억) 벗어남
long l = 3.14f; // long < float
float f = 3.14; // float < double
```
- byte, short 변수에 int 리터럴 저장 가능(단, 변수의 타입의 범위 이내여야 함)
```java
byte b = 100; // OK. byte의 범위(-128~127)에 속함
byte b = 128; // 에러. byte의 범위를 벗어남
```

## 문자와 문자열
```java
// char는 홑따옴표를 사용한다.
char ch = 'A';
char ch = 'AB'; // 에러
char ch = ''; // 에러

// 문자열은 쌍따옴표를 사용한다.
String s = "ABC";
String s1 = "AB"; // 대부분 이 방법을 사용
String s2 = new String("AB");

String s = "A"; // OK
String s = ""; // OK

String S1 = "A" + "B" // "AB"

// 숫자를 문자열로 간단히 변환하는 방법
"" + 7 // -> "" + "7" -> "7"

// 문자열 결합은 왼쪽에서 오른쪽으로 진행되기 때문에 순서가 중요!
"" + 7 + 7 // 14가 아니라 "77"
7 + 7 + "" // "14"
```
- `문자열` + `any type` = `문자열`
- `any type` + `문자열` = `문자열`

## 두 변수의 값 교환하기
- tmp라는 하나의 변수가 추가적으로 필요! (뭐 당연한거지..우유랑 주스랑 바꾼다고 서로 디립따 부으면 그게 바뀌냐 섞이지...)

## 기본형과 참조형
### 기본형(Primitive type)
- 8개 : boolean, char, byte, short, int, long, float, double
- 실제 값을 저장
### 참조형(Reference type)
- 기본형을 제외한 나머지(String, System 등)
- 메모리 주소를 저장(64bit JVM에서 8byte까지)
```java
Date today; // 참조형 변수 today를 선언
today = new Date(); // today에 객체의 주소를 저장
```
## 기본형 - 종류와 크기
- 논리형: true와 false중 하나를 값으로 가지며, 조건식과 논리적 계산에 사용된다.
- 문자형 : 문자를 저장하는데 사용되며, 변수 당 하나의 문자만을 저장할 수 있따.
- 정수형: 정수값을 저장하는데 사용된다.
    - 주로 사용하는 것은 int와 long(아주 큰 정수)이다.
    - byte는 이진데이터를 다루는데 사용된다.(이미지파일, 실행파일...)
    - short는 c언어와의 호환을 위해 추가되었으나 잘 쓰이지 않는다.
- 실수형: 실수 값을 저장하는데 사용된다. float와 double이 있다.
```
1bit = 2진수 1자리  
1byte = 8bit(자바에서는 데이터를 다루는 최소 단위가 바이트임)
```

|종류\크기(byte)|1|2|4|8|
|---|---|---|---|---|
|논리형|boolean||||
|문자형||char|||
|정수형|byte|short|int (default)|long|
|실수형|||float|double (default)|

### 표현범위
- 자바에서 정수는 모두 부호가 있다.
- 부호있는 정수의 범위는
    - n비트로 표현할 수 있는 부호있는 정수의 범위 : -2^(n-1) ~ 2^(n-1) - 1
- int 의 범위는 -20억~20억

<br>

- float의 정밀도는 7자리, double의 정밀도는 15자리.
    - 실수에서는 7자리가 그다지 높은 정밀도가 아니기 때문에 double이 디폴트타입

## printf를 이용한 출력
- println()의 단점 : 출력형식 지정불가
    - 실수의 자리 수 제한 출력 불가
    - 10진수로만 출력된다.

### printf()의 지시자
|지시자|설명|
|---|---|
|`%b`|불리언(**b**oolean) 형식으로 출력|
|`%d`|10진(**d**ecimal) 정수의 형식으로 출력|
|`%o`|8진(**o**ctal) 정수의 형식으로 출력|
|`%x`, `%X`|16진(he**x**a-decimal) 정수의 형식으로 출력|
|`%f`|부동 소수점(**f**loating-point)의 형식으로 출력|
|`%e`, `%E`|지수(**e**xponent) 표현식의 형식으로 출력|
|`%c`|문자(**c**haracter)로 출력|
|`%s`|문자열(**s**tring)로 출력|

- 정수를 10진수, 8진수, 16진수로 출력
```java
System.out.printf("%d", 15); // 15
System.out.printf("%o", 15); // 17 : 10진수인 '15'를 8진수인 '17'로 출력
System.out.printf("%x", 15); // f 
// 2진수 지시자는 따로 없고 이렇게 쓴다.
System.out.printf("%s", Integer.toBinaryString(15)); // 1111
```
- 8진수와 16진수에 접두사 붙이기 : `#`
```java
System.out.printf("%#o", 15); // 017
System.out.printf("%#x", 15); // 0xf
// 지시자가 대문자면 출력되는 접두사도 대문자.
System.out.printf("%#X", 15); // 0XF
```
- 실수 출력을 위한 지시자 `%f`, 지수형식 `%e`, 간략한 형식 `%g` (f와 e중 더 간단한 방법을 택함)
- 정수 자리수 지정
```java
System.out.printf("[%5d]\n", 10); // [   10]
System.out.printf("[%-5d]\n", 10); // [10   ]
System.out.printf("[%05d]\n", 10); // [00010]
```
- 실수 자리수 지정
`"%전체자리.소수점아래자리f"`: 전체자리수는 소수점을 포함한다.

- 문자열 자리수 지정
```java
String url = "www.codechobo.com";
System.out.printf("[%s]\n", url); // [www.codechobo.com]
System.out.printf("[%20s]\n", url); // [   www.codechobo.com]
System.out.printf("[%-20s]\n", url); // [www.codechobo.com   ]
System.out.printf("[%.8s]\n", url); // [www.code]
```

## 화면에서 입력받기 - Scanner
### Scanner란?
- 화면으로부터 데이터를 입력받는 기능을 제공하는 클래스
### Scanner를 사용하려면
- import문 추가
    `import java.util.*;`
- Scanner객체의 생성
    `Scanner scanner = new Scanner(System.in)`
- Scanner객체를 사용
```java
int num = scanner.nextInt(); // 화면에서 입력받은 정수를 num에 저장
// 위와 동일한 결과가 나오는 코드
String input = scanner.nextLine(); // 화면에서 입력받은 내용을 input에 저장
int num = Integer.parseInt(input); // 문자열(input)을 숫자(num)로 변환
```

## 정수형의 오버플로우
- 오버플로우 : 표현가능한 범위를 넘는 것
    - 최대값 + 1 -> 최소값
    - 최소값 - 1 -> 최대값

## 타입간의 변환방법
- `문자열.charAt(0)` : String이 char로 바뀜
- `'3'- '0'` : 숫자 3으로 변환
```java
String str = "3";

System.out.println(str.charAt(0) - '0'); // 3
System.out.println('3' - '0' + 1); // 4
System.out.println(Integer.parseInt(str) + 1); // 4
System.out.println(str + 1); // "3" + "1" -> "31"
System.out.println(3 + '0'); // 51
```

# Ch03
## 연산자와 피연산자
- 모든 연산자는 연산 결과를 반환한다.

## 연산자의 우선순위
- 산술 > 비교 > 논리 > 대입
- 단항 > 이항 > 삼항
## 연산자의 결합규칙
- 우선순위가 같은 연산자가 있을 때 어떤 것을 먼저 연산할 것인가?
    - 대입연산자와 단항연산자를 제외하고 모두 왼쪽에서 오른쪽으로 연산 진행

## 증감 연산자
- 전위형 : `++i;`
- 후위형 : `i++;`
- **증감 연산자가 독립적으로 사용된 경우 전위형과 후위형의 차이가 없다.**

<br>

```java
j = ++i; // 전위형

// 아래와 같다.
++i; // 증가 후에
j = i; // 참조하여 대입
```

```java
j = i++; // 후위형

// 아래와 같다.
j = i; // 참조하여 대입 후에
i++; // 증가
```

## 부호 연산자(단항연산자)
- `-` 는 피연산자의 부호를 반대로 변경
- `+` 는 아무런 일도 안하고 실제 사용도 안한다.

## 형변환 연산자
- 형변환: 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
`(타입)피연산자`
```java
double d = 85.6;
int score = (int)d; // 85      반올림되지않는다
```
- 변수 d의 값은 변하지 않는다.

### 자동 형변환
- 표현범위가 좁은 타입을 범위가 넓은 타입으로 변환할 시 컴파일러가 자동으로 형변환해준다.
- long은 8byte고 float은 4byte이지만 long은 표현범위가 10^19이고 float은 10^38이므로
    - long에서 float으로 자동형변환 가능하다.

### 산술 변환
- 연산 전에 피연산자의 타입을 일치시키는 것
    - 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
        - long + int -> long + long -> long
        - float + int -> float + float -> float
        - double + float -> double + double -> double

    - 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
        - byte + short -> int + int -> int
        - char + short -> int + int -> int
            - '2' - '0' -> 50 - 48 -> 2
```java
int a = 1_000_000;    // 1,000,000   1백만 
int b = 2_000_000;    // 2,000,000   2백만 

long c = a * b;       // a * b = 2,000,000,000,000 ?

System.out.println(c); // -1454759936
```
`long c = a * b;` 에서 a*b는 이미 int상태에서 오버플로우가 발생했으므로 아래와 같이 바꿔야함
```java
long c = (long)a * b;
``` 

## 반올림 - Math.round()
- 실수를 소수점 **첫 째자리**에서 반올림한 정수를 반환
- 실수형을 int로 형변환하면 소수점 아래는 버림을 할 수 있음
## 나머지 연산자 `%`
- 피연산자는 0이아닌 정수만 허용
- 피연산자의 부호는 무시됨

## 비교 연산자
- 두 피연산자를 비교해 true 또는 false를 반환

## 문자열의 비교
- 문자열 비교에는 `==` 대신 `equals()`를 사용해야 한다.

## 논리 부정 연산자 `!`
- `ch < 'a' || ch > 'z'` 는 이렇게 바꿀 수 있다. `!('a' <= ch && ch <= 'z')`
    - 둘다 문자 ch가 소문자가 아니라는 의미이다.

## 조건 연산자 `? :`
- 조건식의 결과에 따라 연산결과를 달리한다.
- `조건식 ? 식1 : 식2` : 조건식이 참이면 식1, 거짓이면 식2 를 연산한다.

## 대입 연산자
- **모든 연산자는 결과값을 반환한다**
- 오른쪽 연산자를 왼쪽 피연산자에 저장 후 **저장된 값을 반환**
```java
int x = 0;
System.out.println(x=3);  // 3이 출력됨
```
```java
x = y = 3;

// 연산의 진행 순서는 다음과 같다.
y = 3;
x = y;
```
- lvalue : 대입 연산자의 왼쪽 피연산자
    - 반드시 변수나 배열과 같은 저장공간이어야 한다.
- rvalue : 대입 연산자의 오른쪽 피연산자
```java
int i = 0;      // 에러    
3 = i + 3;      // 에러
i + 3 = i;      // 에러

final int MAX = 3;
          MAX = 10;     // 에러
```

## 복합 대입 연산자
- 대입 연산자와 다른 연산자를 하나로 축약
- ex) `i += 3;`
```java
 i *= 10 + j;       // i = (i * 10) + j; 가 아님에 주의
 i *= (10 + j);     
 i = i * (10 + j);
 // 셋다 똑같다. 
 ```